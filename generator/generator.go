package generator

import (
	"bytes"
	"fmt"
	"gopkg.in/yaml.v2"
	"io"
	"io/ioutil"
	"sort"
	"strings"
	"os"
	"path/filepath"
)

const Version = "0.9.0"

// The Generator is used to generate compilable go code from a yaml configuration
type Generator struct {
	Config Config
	Debug  bool
}

// NewGenerator creates a new Generator instance
func New(config Config) *Generator {
	return &Generator{
		Config: config,
		Debug: false,
	}
}

// Generate reads a yaml type configuration from the `input` and writes the corresponding go code to the `output`.
func (g *Generator) Generate(input io.Reader, output io.Writer) error {
	g.logVerbose("Generating code from input %q with output package %q", g.Config.InputPath, g.Config.Package)
	conf, err := g.parseInput(input)
	if err != nil {
		return fmt.Errorf("could not parse type definition: %s", err)
	}

	err = conf.Validate()
	if err != nil {
		return err
	}

	if g.Config.OutputPath != "" {
		g.generateGoGenerateLine(output)
	}

	fmt.Fprintf(output, "package %s\n\n", g.Config.PackageName())
	g.generateImports(conf, output)
	g.generateGoldiGenComment(output)
	g.generateTypeRegistrationFunction(conf, output)

	// TODO: once done check if the output is valid go code
	return nil
}

func (g *Generator) parseInput(input io.Reader) (*TypesConfiguration, error) {
	g.logVerbose("Parsing input..")
	inputData, err := ioutil.ReadAll(input)
	if err != nil {
		return nil, err
	}

	inputData = g.sanitizeInput(inputData)

	var config TypesConfiguration
	err = yaml.Unmarshal(inputData, &config)
	return &config, err
}

func (g *Generator) sanitizeInput(input []byte) []byte {
	g.logVerbose("Sanitizing input..")
	sanitizedInput := &bytes.Buffer{}
	line := &bytes.Buffer{}
	lineBeginning := true
	for _, c := range input {
		switch c {
		case '\n':
			if strings.TrimSpace(line.String()) != "" {
				sanitizedInput.Write(line.Bytes())
				sanitizedInput.WriteByte('\n')
				line.Reset()
				lineBeginning = true
			}
		case '\t':
			if lineBeginning {
				line.WriteString("    ")
			} else {
				line.WriteByte(c)
			}
		case ' ':
			line.WriteByte(c)
		default:
			lineBeginning = false
			line.WriteByte(c)
		}
	}

	sanitizedInput.Write(line.Bytes())
	return sanitizedInput.Bytes()
}

func (g *Generator) generateGoGenerateLine(output io.Writer) {
	outputFile := filepath.Base(g.Config.OutputPath)
	inputFile, err := filepath.Rel(filepath.Dir(g.Config.OutputPath), g.Config.InputPath)
	if err != nil {
		g.logWarn("Could not create go:generate line: %s", err)
	}

	fmt.Fprintf(output, "//go:generate goldigen --in %q --out %q --package %s --function %s --overwrite --nointeraction\n",
		inputFile, outputFile, g.Config.Package, g.Config.FunctionName,
	)
}

func (g *Generator) generateImports(conf *TypesConfiguration, output io.Writer) {
	g.logVerbose("Generating import packages (ignoring %q)", g.Config.Package)
	packages := conf.Packages("github.com/fgrosse/goldi")

	fmt.Fprint(output, "import (\n")
	for _, pkg := range packages {
		if pkg != g.Config.Package {
			g.logVerbose("Detected new import package %q", pkg)
			fmt.Fprintf(output, "\t%q\n", pkg)
		}
	}

	fmt.Fprint(output, ")\n\n")
}

func (g *Generator) generateGoldiGenComment(output io.Writer) {
	fmt.Fprintf(output, "// %s registers all types that have been defined in the file %q\n", g.Config.FunctionName, g.Config.InputName())
	fmt.Fprintf(output, "//\n")
	fmt.Fprintf(output, "// DO NOT EDIT THIS FILE: it has been generated by goldigen v%s.\n", Version)
	fmt.Fprintf(output, "// It is however good practice to put this file under version control.\n")
	fmt.Fprintf(output, "// See https://github.com/fgrosse/goldi for what is going on here.\n")
}

// TODO the function should defer panic handling and return an error if a panic occurred during type registration
func (g *Generator) generateTypeRegistrationFunction(conf *TypesConfiguration, output io.Writer) {
	fmt.Fprintf(output, "func %s(types goldi.TypeRegistry) {\n", g.Config.FunctionName)
	typeIDs := make([]string, len(conf.Types))
	i := 0
	for typeID, _ := range conf.Types {
		typeIDs[i] = typeID
		i++
	}
	sort.Strings(typeIDs)

	for _, typeID := range typeIDs {
		typeDef := conf.Types[typeID]
		fmt.Fprint(output, "\t")
		fmt.Fprint(output, typeDef.RegistrationCode(typeID, g.Config.Package))
		fmt.Fprint(output, "\n")
	}
	fmt.Fprint(output, "}\n")
}

func (g *Generator) logVerbose(message string, args ...interface{}) {
	if g.Debug {
		fmt.Fprintf(os.Stderr, message+"\n", args...)
	}
}

func (g *Generator) logWarn(message string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, message+"\n", args...)
}
